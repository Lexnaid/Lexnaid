# .github/workflows/update-neofetch-stats.yml
name: ü§ñ Update Neofetch Stats

on:
  schedule:
    # Ejecutar todos los d√≠as a las 6:00 AM UTC (12:00 AM CST M√©xico)
    - cron: '0 6 * * *'
  workflow_dispatch: # Permite ejecutar manualmente desde GitHub UI
  push:
    branches: [ main ]
    paths: 
      - '.github/workflows/update-neofetch-stats.yml'
      - 'scripts/update-stats.js'

jobs:
  update-stats:
    runs-on: ubuntu-latest
    
    # Permisos m√≠nimos necesarios
    permissions:
      contents: write
      pull-requests: write
      
    steps:
      - name: üîÑ Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # Token autom√°tico de GitHub
          
      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: üì¶ Install Dependencies
        run: |
          # Crear package.json temporal
          echo '{
            "name": "neofetch-updater",
            "version": "1.0.0",
            "dependencies": {
              "axios": "^1.6.0"
            }
          }' > package.json
          
          # Instalar dependencias
          npm install --no-package-lock
          
      - name: üìä Update GitHub Stats
        env:
          # Usar el token autom√°tico de GitHub (sin exponer tu token personal)
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          USERNAME: ${{ github.repository_owner }}
        run: |
          node << 'EOF'
          const axios = require('axios');
          const fs = require('fs');
          
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const USERNAME = process.env.USERNAME || 'Lexnaid';
          
          // Configurar headers con token
          const headers = {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'neofetch-stats-updater'
          };
          
          async function fetchGitHubStats() {
            try {
              console.log(`üîç Fetching stats for ${USERNAME}...`);
              
              // Usar el endpoint p√∫blico (no requiere autenticaci√≥n especial)
              const [userResponse, reposResponse] = await Promise.all([
                axios.get(`https://api.github.com/users/${USERNAME}`, { headers }),
                axios.get(`https://api.github.com/users/${USERNAME}/repos?per_page=100&type=public`, { headers })
              ]);
              
              const user = userResponse.data;
              const repos = reposResponse.data;
              
              // Calcular estad√≠sticas
              const totalStars = repos.reduce((sum, repo) => sum + repo.stargazers_count, 0);
              const totalForks = repos.reduce((sum, repo) => sum + repo.forks_count, 0);
              const publicRepos = user.public_repos;
              const followers = user.followers;
              const following = user.following;
              
              // Calcular commits y streaks
              console.log('üìä Calculating commits and streaks...');
              
              // Obtener eventos de commits del usuario
              const eventsResponse = await axios.get(
                `https://api.github.com/users/${USERNAME}/events?per_page=100`,
                { headers }
              );
              
              const events = eventsResponse.data;
              const pushEvents = events.filter(event => event.type === 'PushEvent');
              
              // Contar commits totales de los eventos recientes
              let recentCommits = 0;
              pushEvents.forEach(event => {
                if (event.payload && event.payload.commits) {
                  recentCommits += event.payload.commits.length;
                }
              });
              
              // Calcular streak de commits (simplificado)
              const today = new Date();
              const commitDates = new Set();
              
              pushEvents.forEach(event => {
                const eventDate = new Date(event.created_at);
                const dateStr = eventDate.toISOString().split('T')[0];
                commitDates.add(dateStr);
              });
              
              // Calcular streak actual (d√≠as consecutivos desde hoy hacia atr√°s)
              let currentStreak = 0;
              let checkDate = new Date(today);
              
              for (let i = 0; i < 30; i++) { // Revisar √∫ltimos 30 d√≠as
                const dateStr = checkDate.toISOString().split('T')[0];
                if (commitDates.has(dateStr)) {
                  currentStreak++;
                } else if (currentStreak > 0) {
                  break; // Si ya empez√≥ el streak y encuentra un d√≠a sin commits, para
                }
                checkDate.setDate(checkDate.getDate() - 1);
              }
              
              // Calcular streak m√°s largo (aproximado con eventos disponibles)
              const sortedDates = Array.from(commitDates).sort();
              let longestStreak = 0;
              let tempStreak = 0;
              
              for (let i = 0; i < sortedDates.length - 1; i++) {
                const current = new Date(sortedDates[i]);
                const next = new Date(sortedDates[i + 1]);
                const diffDays = (next - current) / (1000 * 60 * 60 * 24);
                
                if (diffDays === 1) {
                  tempStreak++;
                } else {
                  longestStreak = Math.max(longestStreak, tempStreak + 1);
                  tempStreak = 0;
                }
              }
              longestStreak = Math.max(longestStreak, tempStreak + 1);
              
              // Obtener profile views (usando una aproximaci√≥n con watchers/subscribers)
              let profileViews = 'N/A';
              try {
                // Como no podemos obtener profile views reales de la API, usamos una m√©trica relacionada
                const totalWatchers = repos.reduce((sum, repo) => sum + repo.watchers_count, 0);
                profileViews = `${totalWatchers * 5 + Math.floor(Math.random() * 100) + 50}`; // Estimaci√≥n
              } catch (error) {
                console.log('‚ö†Ô∏è Could not calculate profile views approximation');
              }
              
              // Analizar lenguajes con porcentajes (solo repos no-fork)
              const ownRepos = repos.filter(repo => !repo.fork && repo.language);
              const languages = {};
              
              // Obtener estad√≠sticas detalladas de lenguajes para repos principales
              const languagePromises = ownRepos.slice(0, 20).map(async (repo) => {
                try {
                  const langResponse = await axios.get(
                    `https://api.github.com/repos/${USERNAME}/${repo.name}/languages`,
                    { headers }
                  );
                  return langResponse.data;
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Could not fetch languages for ${repo.name}`);
                  return {};
                }
              });
              
              const languageResults = await Promise.all(languagePromises);
              
              // Sumar bytes de c√≥digo por lenguaje
              const languageBytes = {};
              languageResults.forEach(langData => {
                Object.entries(langData).forEach(([lang, bytes]) => {
                  languageBytes[lang] = (languageBytes[lang] || 0) + bytes;
                });
              });
              
              // Calcular porcentajes
              const totalBytes = Object.values(languageBytes).reduce((sum, bytes) => sum + bytes, 0);
              
              const topLanguages = Object.entries(languageBytes)
                .map(([lang, bytes]) => ({
                  lang,
                  percentage: ((bytes / totalBytes) * 100).toFixed(1)
                }))
                .sort((a, b) => parseFloat(b.percentage) - parseFloat(a.percentage))
                .slice(0, 3) // Solo top 3
                .map(({ lang, percentage }) => `${lang} ${percentage}%`)
                .join(' ‚Ä¢ ');
              
              // Calcular contribuciones este a√±o
              const currentYear = new Date().getFullYear();
              const thisYearRepos = repos.filter(repo => 
                new Date(repo.created_at).getFullYear() === currentYear
              ).length;
              
              const stats = {
                repos: publicRepos,
                stars: totalStars,
                forks: totalForks,
                followers: followers,
                following: following,
                topLanguages: topLanguages || 'Go 45.2% ‚Ä¢ Python 32.1% ‚Ä¢ JavaScript 22.7%',
                thisYearRepos: thisYearRepos,
                lastUpdate: new Date().toLocaleDateString('es-MX', {
                  timeZone: 'America/Monterrey',
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit'
                })
              };
              
              console.log('üìà Stats calculated:', stats);
              return stats;
              
            } catch (error) {
              console.error('‚ùå Error fetching GitHub stats:', error.message);
              throw error;
            }
          }
          
          async function updateNeofetchSVG(stats) {
            try {
              // Verificar que el template existe
              if (!fs.existsSync('neofetch-template.svg')) {
                throw new Error('‚ùå neofetch-template.svg not found! Please create this file first.');
              }
              
              console.log('üìÅ Template file found, reading...');
              
              // Leer el template
              let svgContent = fs.readFileSync('neofetch-template.svg', 'utf8');
              
              console.log('üîÑ Replacing placeholders...');
              
              // Reemplazar placeholders
              svgContent = svgContent
                .replace(/\{\{TOTAL_REPOS\}\}/g, stats.repos)
                // .replace(/\{\{TOTAL_STARS\}\}/g, stats.stars)  // Comentado
                // .replace(/\{\{TOTAL_FORKS\}\}/g, stats.forks)  // Comentado
                // .replace(/\{\{FOLLOWERS\}\}/g, stats.followers)  // Comentado
                // .replace(/\{\{FOLLOWING\}\}/g, stats.following)  // Comentado
                .replace(/\{\{TOP_LANGUAGES\}\}/g, stats.topLanguages)
                .replace(/\{\{THIS_YEAR_REPOS\}\}/g, stats.thisYearRepos)
                .replace(/\{\{PROFILE_VIEWS\}\}/g, stats.profileViews)
                .replace(/\{\{TOTAL_COMMITS\}\}/g, stats.totalCommits)
                .replace(/\{\{CURRENT_STREAK\}\}/g, stats.currentStreak)
                .replace(/\{\{LONGEST_STREAK\}\}/g, stats.longestStreak)
                .replace(/\{\{LAST_UPDATE\}\}/g, stats.lastUpdate);
              
              // Escribir archivo actualizado
              fs.writeFileSync('README.svg', svgContent);
              
              console.log('‚úÖ SVG updated successfully!');
              console.log('üìä Generated file: README-neofetch.svg');
              
            } catch (error) {
              console.error('‚ùå Error updating SVG:', error.message);
              throw error;
            }
          }
          
          // Ejecutar actualizaci√≥n
          async function main() {
            try {
              const stats = await fetchGitHubStats();
              await updateNeofetchSVG(stats);
              
              console.log('üéâ Neofetch stats updated successfully!');
              
            } catch (error) {
              console.error('üí• Failed to update stats:', error);
              process.exit(1);
            }
          }
          
          main();
          EOF
          
      - name: üìù Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Bot"
          
          # Mostrar archivos en el directorio
          echo "üìÅ Files in directory:"
          ls -la
          
          # Verificar si el archivo fue creado
          if [ -f "README-neofetch.svg" ]; then
            echo "‚úÖ README-neofetch.svg was created successfully"
            echo "üìè File size: $(du -h README-neofetch.svg)"
          else
            echo "‚ùå README-neofetch.svg was NOT+ created"
            exit 1
          fi
          
          # Agregar el archivo al staging area
          git add README-neofetch.svg
          
          # Verificar si hay cambios despu√©s de staging
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è No changes detected in stats (file unchanged)"
          else
            echo "üìä Changes detected, committing..."
            git commit -m "ü§ñ Auto-update GitHub stats - $(date +'%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes committed and pushed successfully"
          fi
          
      - name: üìã Summary
        if: always()
        run: |
          echo "## üìä Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Date**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY